0.机器,OS,编程语言
	
	机器只能执行自身CPU指令集内的二进制指令(指令是01代码,操作数是01代码,字符是01代码,图片是01代码,所有都是01代码)
	
	
	为了便于人的记忆和编程,汇编语言(低级语言)出现,汇编语言="特定CPU的指令集"的助记符号(将上述变为人方便记忆的符号,如:001=ADD,002=MOV...)
	
	
	最终的程序由几大部分组成:
	
	1.CPU指令集
	2.特殊的硬件访问控制
	3.不同OS的System Call(对宿主环境的请求)
	
	以C语言为例:
	
	1.不同CPU指令集上的编译器可以将一份同样的C语言代码最终编译成不同指令
	2.硬件厂商会提供C语言的接口(*.h)和各自具体OS的实现(驱动程序)
	3.ASNI规范了一套c语言的System Call的接口(*.h),各自OS各自实现(不同的OS也有不再ASNI范围内的System Call,但OS提供提供了接口,这就让语言维持在小的规模,让不同OS的宿主各自实现系统库来处理移植问题)
	
	
    语言语法+(不同OS上的库+不同OS上的编译器) 			
    											=> 不同机器相应的指令集
    语言语法+(不同OS上的库+不同OS上的编译器+解释器)
    
    
	高级语言根据语法和描述逻辑来编写程序,而不是按特定CPU或机器相关的指令集来编写程序
	
     

				
    
    
    
    
1.C语言

	C由Unix产生,C重写了Unix,Unix like 通常自带C编译器
	
	ASNI产生一个机器无关的语言规范ASNI C和标准的函数库进而统一规范方便移植
	
	语言语法精简,很多功能都有标准库函数提供
	
	产生了两个变异 C++,OC
	
	
2.C程序的产生过程

							     	 	启动代码(代码于OS之间的接口,不同的OS不同)
	源代码(*.h,*.c)->[编译器预编译,编译]->	目标代码(*.obj)						->[链接器链接]->可执行文件
								 	 	库代码(stdio...)
								
3.编译器,文件名

			编译器		目标文件		执行文件
	Unix	cc			*.o			*.out
	Linux   GNU gcc		*.			*.out
	Windows 多种			*.obj		*.exe
	Mac		clang		*.obj		同名
	  		
	  		
4.预处理,#include,条件编译

	编译器拿到原文件，不是马上进行编译，而是先进行源代码的预处理,#include其实只是复制粘合并代码,#include甚至不是C语法的一部分。
	
	
5.简单框架

	＃include <stdio.h>
	int main(void){
		statments;
		return 0;
	}
	
	 main 是OS与程序的入口 int 是返回给OS的值.
	
	常用的库:
			stdio.h:输入输出
			stdlib:OS功能lib,如:malloc(),free()
			ctype.h:char处理
			string.h:字符串处理
			stdbool.h(C99):bool,_Bool处理
			math.h:数学函数
	
6.C语言程序

	程序是人类希望计算机采取何种行为的描述术语,编译器负责把这部分描述术语转化和底层机器语言,程序需要按照编译器的术语来描述，术语就是语言语法的标准和格式规则
	
	一句C语言代码编译过来可能对应很多句机器指令
	
	不同的语言术语和规则(语法)不一样,但是总比直接使用机器指令要好.
	
	
7.数据(承载信息的数字,字符,图片,声音)


	数据类型				变量							常量
	int 				a					=		0	;
	多大空间装这个数据		数据的起始内存地址				赋值
	
	
	C是强类型语言，变量都有类型(规定容纳它的空间大小)
	

8.基本类型
	
	char:8,实际的存储是数字(byte),机器决定有无符号,字符常量是‘A’,'\X'表示特殊用途的字符，而不是显示的原意        sizeof(char)=1
	
	short: 至少16																				sizeof(short)=2
	
	int: 至少16 or 32,一般是32																		sizeof(int)=4
	
	long:  至少32																				sizeof(long)=4
	
	long long:至少64																				sizeof(8)=1
	
	
	16			16or32	32			64
	short	<=	int 	<=long	<long long
	
	
	float:6位有效数字									sizeof(float)=4
	
	double:10为有效数字								sizeof(double)=8
	
	long double:大于10位有效数字
		
	ASNI C 没有 long float类型	
	
	组合基本类型使用
	signed
	unsigned
	
	
	_Bool:0 or 1 c99标准
	
	
	
	long 常量:XL
	long long常量:XLL
	float常量:Xf
	
	123.4f 1.234E2f 都可以表示浮点数
	
	
	各种整数类型和组合符号目的是表达不同大小范围的整数以及整数是否可取负值
	各种实数类型和组合符号目的是表达不同大小范围的实数以及实数是否可取负值,实数小数点后的位数(有效位)的多少
	
	为了编程的方便和书写的方便产生了8进制和16进制(机器最终还是只理解2进制)
	
	0开头是8进制
	0X开头是16进制
	
	参考 limits.h  float.h
	
	
9.数组(同一类型数据元素连续有序序列),特殊数组:(字符数组,字符串),

	数组是相同类型的连续存储空间
	字符串和字符数组都是字符存储在连续的单元格中的,
	
	字符串就是一个以'\0'字符结尾的字符数组
	字符数组含有'\0'就构成了一个字符串
	
	char  array[10];
	array[0]='a';array[1]='b';array[2]='c';array[3]='\0';
	
	sizeof(array) = 10;
	strlen(array) =	3;
	
	
	
	char* a=['1','2','3',' ','\0'];   			<==>			char* a="123 "
	                      不是可打印字符‘0’
	                      而是不可打印的转译字符'\0'
	                      表示字符串的结尾
	
	
	sizeof a=4 指针的存储大小
	strlen a=4 字符串的长度 
	
	
	strlen:是字符串的实际长度,空格也算进去,结束标志是'\0'
	sizof:是实际存储空间大小(数组和字符串在这个地方处理不一样)
	
	
10.scanf printf

	scanf在遇到第一个 空格 tab 换行 会停止读取
	如果 输入 123[空格|tab|\n]456789 真正读取到的是123
	
11.#define CONSTANT 123 <==> const int CONSTANT =123


12.函数

	使用函数的目的:
	1.模块化
	2.复用


	声明和定义
	1.ANSI C函数使用前一定要预先声明或定义:
	2.声明的目的时编译器检查错误
	3.声明和使用三只形式:	
			a.通过#include <> 第三方*.h(库) 引入要使用的函数声明 并使用函数
			b.通过#include "" 自定的*.h 引入要使用的函数声明 并使用函数
			c.使用时即时声明和定义函数
	4.C语言的函数的参数调用都是传值调用(函数参数是指针类型的参数时传递的还是值是地址值)
	5.声明时 int f(int,int,int) <=> int f(int a,int b,int c)
	6.stdarg.h 头文件处理函数参数的类型和个数不确定的情况
	
	
	多源码文件的组织:
	1.将"外部要使用"的"函数"的声明,变量的声明,"常量"的"#define" 都放在一个公共有的*.h中,函数的实现,变量的定义放在同名的*.c中
	2.*.c文件编写时也要将同名的*.h #include进来,以防实现函数是函数的项目调用和用到声明时的
	3.将只在*.c文件内部使用的函数定义加上static关键字，将只在*.c文件内部使用的变量和常量定义前加上static
	

13.指针

	1.short a =1;  
	
	a编译后是一块内存的"地址的起始值",这块内存的地址的起始值和接下来的2个字节的空间(例子是short类型)存储的是二进制的1,一旦使用a,a代表的就是这个起始地址里面存储的两个字节的数值

	2.short* b=0;
	  b=&a;
	
	b编译后是一块内存的“地址的起始值”,“这块内存的地址的起始值和接下来的4个字节的空间(存储地址的指针类型的变量的数据空间固定是4个字节)存储的是a的起始地址而不是a变量存储的值,
	一旦使用b,b代表的就是这个起始地址里面存储的四个字节的”地址值“,也就是a的起始地址值;一旦使用*b,*b就代表b存储的地址值对应的内存块的数值(本例中就是a里面存储的值）
	
	指针之所以有类型是因为*b计算得到了*b地址对应的内存单元后还需要了解*b内存的操作范围,由于内存是连续的,只有起始地址没有数据长度,就不知道操作数的大小和范围。

	大多数语言使用"引用类型"和"基本类型"表示基本类型和指针类型,c语言可以直接得到地址和操作地址,c语言使用指针的目的是类似高级语言中引用的目的,而不是要了解地址数值。	
		

14.数组和指针

	数组:
	int a[]={1,2,3};
	
	int a[10]=[1,2,3,4]
	
	int a[10]; a[0]=1;a[1]=2;
	
	除了初始化,不允许整体赋值
	
	C99 可以VLA变长数组声明了
	
	数组名同时也是数组首元素地址 a=&a[0]
	
	
	声明和定义时
	[type] func(type*)  <==> [type] func(type a[]);
	处理数组的函数其实是指针作为参数的,处理数组和指针的运算往往可以互换
	a[i]  *(a+i) 是等价的 不论 a是数组还是指针
	a++表达式只能是a是指针声明时
	
	指针:
	
	int* p;
	int* p1
	操作
	1.赋值 p=NULL
	2.求值 *p 
	3.取地址 &p (指针的指针)
	4.+n,-n,++,--
	5.求差 p1-p
	
	未初始化的指针不可取值
	不同类型的指针变量不要相护操作
	
	函数传递参数 int 还是 int*? 不修改原值就int 修改原值就int* 数组名就是首地址
	
	
15.作用域,链接,存储时间
	
	两类作用域
	1.文件作用域:*.c文件内,函数定义外定义的变量
	2.代码块作用域:{},for{},while {},函数中定义的变量
	
	三类链接
	a.外部链接 	非static定义
	b.内部链接   	static定义
	c.空链接    	代码块非static定义
	
	2c构成了只能在块内访问的变量
	1a构成了在程序任何地方都能访问的变量
	1b构成了在当前*.c文件内部任何地方都能访问的变量
	
	
	存储时间
	静态:1
	动态:2
	
	
	
	综上:
	1.{int i=0;}
	
	2.int i;
	  void func(){
	  	i=1;
	  }
	  
	3.static int i;
	  void func(){
	  	i=1;
	  }
	
	4.void func(){
	 	static int i=0;
	  }
	
	
	
	